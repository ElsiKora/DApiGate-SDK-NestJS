/**
 * DApiGate
 * DApiGate `Reaper API` documentation
 *
 * The version of the OpenAPI document: 1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { HttpService } from "@nestjs/axios";
import { Injectable, Optional } from "@nestjs/common";

import { Configuration } from "../configuration";

import type { ProxyGetListResponseDTO } from "../model/proxy-get-list-response-dto.model";
import type { AxiosResponse } from "axios";
import type { Observable } from "rxjs";

@Injectable()
export class ProxyService {
	protected basePath = "https://reaper.dapigate.com";

	public configuration = new Configuration();

	public defaultHeaders: Record<string, string> = {};

	constructor(
		protected httpClient: HttpService,
		@Optional() configuration: Configuration,
	) {
		this.configuration = configuration || this.configuration;
		this.basePath = configuration?.basePath || this.basePath;
	}

	/**
	 * @param consumes string[] mime-types
	 * @return true: consumes contains 'multipart/form-data', false: otherwise
	 */
	private canConsumeForm(consumes: Array<string>): boolean {
		const form = "multipart/form-data";

		return consumes.includes(form);
	}

	/**
	 * Fetching list of &#x60;Proxys&#x60;
	 * This method is used for fetching list of &#x60;Proxys&#x60;
	 * @param limit ProxyGetResponseDTO Items per page
	 * @param page ProxyGetResponseDTO Page to return
	 * @param country Proxy code
	 * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
	 * @param reportProgress flag to report request and response progress.
	 */
	public proxyControllerGetList(limit: number, page: number, country?: string): Observable<AxiosResponse<ProxyGetListResponseDTO>>;
	public proxyControllerGetList(limit: number, page: number, country?: string): Observable<any> {
		if (limit === null || limit === undefined) {
			throw new Error("Required parameter limit was null or undefined when calling proxyControllerGetList.");
		}

		if (page === null || page === undefined) {
			throw new Error("Required parameter page was null or undefined when calling proxyControllerGetList.");
		}

		const queryParameters = new URLSearchParams();

		if (limit !== undefined && limit !== null) {
			queryParameters.append("limit", <any>limit);
		}

		if (page !== undefined && page !== null) {
			queryParameters.append("page", <any>page);
		}

		if (country !== undefined && country !== null) {
			queryParameters.append("country", <any>country);
		}

		const headers = { ...this.defaultHeaders };

		// to determine the Accept header
		const httpHeaderAccepts: Array<string> = ["application/json"];
		const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);

		if (httpHeaderAcceptSelected != undefined) {
			headers["Accept"] = httpHeaderAcceptSelected;
		}

		// to determine the Content-Type header
		const consumes: Array<string> = [];

		return this.httpClient.get<ProxyGetListResponseDTO>(`${this.basePath}/v1/proxy`, {
			headers: headers,
			params: queryParameters,
			withCredentials: this.configuration.withCredentials,
		});
	}
}
